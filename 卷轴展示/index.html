<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>古风卷轴3D动态展示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0a0a0a;
            font-family: 'SimSun', serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 初始化Three.js场景、相机和渲染器
        let scene, camera, renderer;
        let scroll, leftAxis, rightAxis, paper;
        let animationProgress = 0;
        let isAnimating = true;
        let textCanvas, textTexture;
        let raycaster, mouse;
        let isClosing = false;
        
        // 《汉魂檄》文字内容
        const hanHunXi = [
            "《汉魂檄》原文如下：",
            "",
            "告五千年中原大地，十四亿华夏子民。",
            "浩浩乎百万里水府，巍巍然十万载山君。",
            "乾坤未定，华夏当兴；风云方急，汉脉须清。",
            "外有群狼窥伺，肆动阴云；内有野犬曲笔，妄改古今。",
            "使我六经不辨，典礼难行；欲断我文脉，惑乱苍生；",
            "乱我根柢，移我气凝。然我华夏之魂，非一朝一夕之火；",
            "五千春秋之风骨，在史册，在江河，在众心。",
            "昔秦皇扫六合，剑指八荒；亦汉武开边陲，封狼居胥。",
            "唐宗之盛，笔落惊风；宋儒之思，心正理明；",
            "明旗猎猎，定海波平；先贤血脉，气节传薪。",
            "三百载虫豸让国土，百余年蚕食人丁零；",
            "亿万英魂，亿万兵。先贤血泪尚未干，魑魅起舞正犹酣；",
            "吾将以脊梁作长剑，扫荡九州，日月还！",
            "吾华夏儿女，骨正刚，血正燃，正当外攘嗟尔，内肃遗蛮！",
            "吾华夏儿女，当以心辩，不为风摇；以史为镜，不为势惑；",
            "守其清流，破其浊浪；定其本根，续其长纲。",
            "今以此檄告天下：汉风可折未可断，汉骨可伏未可弯！",
            "但使人心不没，虽远必复！ 但使文脉不绝，虽弱终兴！",
            "",
            "愿当世华夏兄妹：",
            "挺膺立雪，守道如初；",
            "不为虚声所惑，不为异说所移；",
            "清源自涤，正本自立；",
            "复我华夏文化，传我中国文明！"
        ];
        
        // 动画参数
        const ANIMATION_DURATION = 9000; // 总动画时长（毫秒）
        const SCROLL_WIDTH = 35; // 再次增大卷轴总宽度，确保文字完整显示
        const SCROLL_HEIGHT = 18; // 大幅增大卷轴高度，匹配2400px的Canvas高度
        const AXIS_RADIUS = 0.4; // 相应增大卷轴轴半径
        
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            
            // 加载背景图片
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('./bg.png', function(texture) {
                scene.background = texture;
            });
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            // 调整相机位置，确保横向纸张完整可见，并向右平移整体布局
            // 相机z位置不再与SCROLL_WIDTH挂钩，使用固定距离确保视觉大小一致
            camera.position.set(2, 0, 25);
            camera.lookAt(2, 0, 0);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // 添加窗口大小调整事件
            window.addEventListener('resize', onWindowResize);
            
            // 创建卷轴组件
            createScroll();
            
            // 添加光照
            addLighting();
            
            // 初始化Raycaster和鼠标向量用于点击检测
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // 添加鼠标点击事件监听
            window.addEventListener('click', onMouseClick);
            
            // 开始动画循环
            animate();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            
            // 调整相机位置以适应不同屏幕尺寸
            // 保持相机z位置相对固定，确保卷轴视觉大小一致
            const maxDimension = Math.max(window.innerWidth, window.innerHeight);
            camera.position.z = Math.max(25, maxDimension / 80); // 增大分母，减小随窗口变化的幅度
            
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 渲染循环
        function animate() {
            requestAnimationFrame(animate);
            
            if (isAnimating) {
                updateScrollAnimation();
            }
            
            renderer.render(scene, camera);
        }
        
        // 创建卷轴函数
        function createScroll() {
            // 创建木质纹理加载器
            const woodTextureLoader = new THREE.TextureLoader();
            const woodTexture = woodTextureLoader.load('./img1.png');
            woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(1, 3); // 适应垂直轴的纹理重复
            
            // 创建宣纸纹理加载器
            const paperTextureLoader = new THREE.TextureLoader();
            const paperTexture = paperTextureLoader.load('./img1.png');
            paperTexture.wrapS = paperTexture.wrapT = THREE.RepeatWrapping;
            paperTexture.repeat.set(2, 1); // 重复宣纸纹理
            
            // 调整卷轴轴长度，使其略高于纸张高度（垂直轴）
            const axisLength = SCROLL_HEIGHT + 0.2;
            
            // 创建左侧垂直轴
            const axisGeometry = new THREE.CylinderGeometry(AXIS_RADIUS, AXIS_RADIUS, axisLength, 32);
            const woodMaterial = new THREE.MeshPhongMaterial({ 
                map: woodTexture,
                side: THREE.DoubleSide
            });
            
            leftAxis = new THREE.Mesh(axisGeometry, woodMaterial);
            // 保持垂直方向（沿Y轴）
            // leftAxis.rotation保持默认（0,0,0）即可
            // 左侧轴初始位置在右侧，与右侧轴重合
            leftAxis.position.set(SCROLL_WIDTH / 2 - AXIS_RADIUS, 0, 0);
            scene.add(leftAxis);
            
            // 创建右侧垂直轴
            rightAxis = new THREE.Mesh(axisGeometry, woodMaterial);
            // 保持垂直方向（沿Y轴）
            // rightAxis.rotation保持默认（0,0,0）即可
            // 右侧轴固定在右侧
            rightAxis.position.set(SCROLL_WIDTH / 2 - AXIS_RADIUS, 0, 0);
            scene.add(rightAxis);
            
            // 创建卷轴组
            scroll = new THREE.Group();
            scene.add(scroll);
            
            // 创建文字Canvas
            textCanvas = document.createElement('canvas');
            // 大幅增大Canvas高度，确保所有垂直文字都能完整显示
            const canvasWidth = 2400;
            const canvasHeight = 2400; // 从1600增加到2400，大幅提高垂直容纳能力
            textCanvas.width = canvasWidth;
            textCanvas.height = canvasHeight;
            const ctx = textCanvas.getContext('2d');
            
            // 绘制圣旨背景到Canvas
            ctx.fillStyle = '#f0e68c'; // 使用与后续渲染一致的金色背景
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 创建文字纹理
            textTexture = new THREE.CanvasTexture(textCanvas);
            textTexture.needsUpdate = true;
            
            // 创建纸面，结合宣纸纹理和文字
            // 初始宽度很小，随着展开而增加
            const paperGeometry = new THREE.PlaneGeometry(0.1, SCROLL_HEIGHT, 1, 1);
            const paperMaterial = new THREE.MeshPhongMaterial({ 
                map: textTexture, // 使用包含文字的Canvas纹理
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0
            });
            
            paper = new THREE.Mesh(paperGeometry, paperMaterial);
            // 初始位置在右侧，稍微向前一点避免与轴重叠
            paper.position.set(SCROLL_WIDTH / 2 - AXIS_RADIUS, 0, 0.01);
            scroll.add(paper);
        }
        
        // 添加光照函数
        function addLighting() {
            // 环境光 - 提供基础照明
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // 平行光 - 模拟主光源（如阳光）
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 10);
            directionalLight.castShadow = true;
            
            // 设置阴影属性
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            
            scene.add(directionalLight);
            
            // 点光源 - 添加额外的深度和高光
            const pointLight = new THREE.PointLight(0xffffff, 0.3);
            pointLight.position.set(-5, 0, 5);
            scene.add(pointLight);
            
            // 启用渲染器的阴影映射
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 软阴影
            
            // 使卷轴和纸面能够接收和投射阴影
            leftAxis.castShadow = true;
            leftAxis.receiveShadow = true;
            rightAxis.castShadow = true;
            rightAxis.receiveShadow = true;
            paper.castShadow = true;
            paper.receiveShadow = true;
        }
        
        // 更新卷轴动画函数
        function updateScrollAnimation() {
            // 使用简单的缓动函数使动画更自然，避免回弹
            const easeOutQuad = (t) => t * (2 - t);
            
            if (isClosing) {
                // 处理关闭动画
                const easeInQuad = (t) => t * t;
                
                if (animationProgress > 0) {
                    // 更新动画进度（反向）
                    animationProgress -= (1 / (ANIMATION_DURATION / 16.67)); // 假设60fps
                    animationProgress = Math.max(animationProgress, 0);
                    
                    // 应用缓动效果
                    const easedProgress = easeInQuad(animationProgress);
                    
                    // 计算新的纸面宽度（从左往右关闭）
                    const newWidth = easedProgress * (SCROLL_WIDTH - 2 * AXIS_RADIUS);
                    
                    // 高效更新纸面宽度（避免频繁创建新几何体）
                    paper.scale.x = newWidth / 0.1; // 基于初始宽度0.1进行缩放
                    
                    // 更新纸面位置（保持右侧对齐，向右关闭）
                    paper.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - newWidth / 2;
                    
                    // 更新左侧轴位置（从左往右移动）
                    leftAxis.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - newWidth;
                    
                    // 右侧轴保持固定不动
                    
                    // 更新文字显示，传递展开进度和实际宽度
                    updateTextDisplay(easedProgress, newWidth);
                } else {
                    // 确保完全关闭的最终状态正确
                    paper.scale.x = 0.1 / 0.1;
                    paper.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - 0.1 / 2;
                    leftAxis.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS;
                    updateTextDisplay(0, 0.1);
                    isAnimating = false;
                    isClosing = false;
                }
            } else {
                // 处理打开动画
                if (animationProgress < 1) {
                    // 更新动画进度
                    animationProgress += (1 / (ANIMATION_DURATION / 16.67)); // 假设60fps
                    animationProgress = Math.min(animationProgress, 1);
                    
                    // 应用缓动效果
                    const easedProgress = easeOutQuad(animationProgress);
                    
                    // 计算新的纸面宽度（从右往左展开）
                    const newWidth = easedProgress * (SCROLL_WIDTH - 2 * AXIS_RADIUS);
                    
                    // 高效更新纸面宽度（避免频繁创建新几何体）
                    paper.scale.x = newWidth / 0.1; // 基于初始宽度0.1进行缩放
                    
                    // 更新纸面位置（保持右侧对齐，向左展开）
                    paper.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - newWidth / 2;
                    
                    // 更新左侧轴位置（从右往左移动）
                    leftAxis.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - newWidth;
                    
                    // 右侧轴保持固定不动
                    
                    // 更新文字显示，传递展开进度和实际宽度
                    updateTextDisplay(easedProgress, newWidth);
                } else {
                    // 确保完全摊开的最终状态正确
                    const finalWidth = SCROLL_WIDTH - 2 * AXIS_RADIUS;
                    paper.scale.x = finalWidth / 0.1;
                    paper.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - finalWidth / 2;
                    leftAxis.position.x = SCROLL_WIDTH / 2 - AXIS_RADIUS - finalWidth;
                    updateTextDisplay(1, finalWidth);
                    isAnimating = false;
                }
            }
        }
        
        // 更新文字显示函数 - 垂直打字机逐字效果
        function updateTextDisplay(progress, newWidth) {
            const ctx = textCanvas.getContext('2d');
            const canvasWidth = textCanvas.width;
            const canvasHeight = textCanvas.height;
            
            // 清除Canvas - 使用与檄文纸张匹配的底色
            ctx.fillStyle = '#f5f0e6';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 绘制檄文纸张纹理作为背景（底层）
            ctx.save();
            ctx.globalAlpha = 0.9;
            
            // 创建宣纸底色 - 米白色（檄文常用纸张颜色）
            const gradient = ctx.createLinearGradient(0, 0, canvasWidth, canvasHeight);
            gradient.addColorStop(0, '#f5f0e6'); // 浅米白色
            gradient.addColorStop(1, '#e8e0d0'); // 稍深的米白色
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 添加纸张纹理效果
            ctx.globalAlpha = 0.05;
            ctx.fillStyle = '#333333';
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * canvasWidth;
                const y = Math.random() * canvasHeight;
                const size = Math.random() * 2;
                ctx.fillRect(x, y, size, size);
            }
            
            // 添加纸张纤维效果
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.03;
            for (let i = 0; i < 100; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * canvasWidth, Math.random() * canvasHeight);
                ctx.lineTo(Math.random() * canvasWidth, Math.random() * canvasHeight);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // 设置文字样式（上层）- 优化字体和清晰度
            ctx.font = "62px SimHei, STHeiti, 'Microsoft YaHei', serif"; // 使用更可靠的中文字体栈
            ctx.fillStyle = "#000000"; // 纯黑色文字，彰显檄文的庄重与威严
            ctx.strokeStyle = "#DAA520"; // 金色描边，与圣旨背景协调统一
            ctx.lineWidth = 6; // 精细描边，提高清晰度
            
            // 启用文字抗锯齿和子像素渲染
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // 垂直文本排版参数 - 大幅增大间距，提高可读性
            const charSize = 62; // 与字体大小匹配
            const verticalSpacing = 88; // 大幅增大垂直间距，提高可读性
            const horizontalSpacing = 88; // 大幅增大列间距，避免文字拥挤
            const padding = 100; // 增大边距，为居中显示提供空间
            
            // 计算总字数和当前应显示的字数 - 确保与卷轴动画9秒时长完全匹配
            let totalChars = 0;
            for (let line of hanHunXi) {
                totalChars += line.length;
            }
            
            // 确保文字出现速度与卷轴展开完全同步
            const currentChars = Math.ceil(progress * totalChars);
            
            // 绘制文字 - 垂直从上到下逐字显示，整体水平居中
            let charsDisplayed = 0;
            let currentColumn = 0;
            let currentRow = 0;
            
            // 计算总列数（行数）
            const totalColumns = hanHunXi.length;
            // 计算所有列的总宽度
            const totalTextWidth = (totalColumns - 1) * horizontalSpacing;
            // 计算文本块的起始X位置，使整体水平居中
            const startX = (canvasWidth - totalTextWidth) / 2;
            
            for (let lineIndex = 0; lineIndex < hanHunXi.length; lineIndex++) {
                const line = hanHunXi[lineIndex];
                const lineLength = line.length;
                
                // 计算当前列的X位置 - 基于居中起始位置
                const columnX = startX + currentColumn * horizontalSpacing;
                
                // 逐字绘制当前行的字符
                for (let charIndex = 0; charIndex < lineLength; charIndex++) {
                    if (charsDisplayed >= currentChars) {
                        break;
                    }
                    
                    const char = line[charIndex];
                    const charY = padding + charIndex * verticalSpacing;
                    
                    // 确保文字在Canvas范围内显示
                    if (charY > canvasHeight - padding) {
                        break; // 超出Canvas范围，不再绘制
                    }
                    
                    // 绘制单个字符 - 添加描边增强清晰度
                    ctx.strokeText(char, columnX, charY);
                    ctx.fillText(char, columnX, charY);
                    
                    charsDisplayed++;
                }
                
                if (charsDisplayed >= currentChars) {
                    break;
                }
                
                // 移动到下一列
                currentColumn++;
            }
            
            // 更新纹理
            textTexture.needsUpdate = true;
        }
        
        // 鼠标点击事件处理函数
        function onMouseClick(event) {
            // 将鼠标点击位置转换为Three.js的标准化设备坐标
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // 更新射线投射器的射线
            raycaster.setFromCamera(mouse, camera);
            
            // 检查射线与左侧轴和右侧轴的交点
            const leftIntersects = raycaster.intersectObject(leftAxis);
            const rightIntersects = raycaster.intersectObject(rightAxis);
            
            // 如果点击到了左侧轴，且卷轴已完全打开且不在动画中，则开始关闭动画
            if (leftIntersects.length > 0 && animationProgress >= 1 && !isAnimating) {
                isClosing = true;
                isAnimating = true;
            }
            // 如果点击到了右侧轴，且卷轴已完全关闭或正在关闭且不在动画中，则开始展开动画
            else if (rightIntersects.length > 0 && (animationProgress <= 0 || isClosing) && !isAnimating) {
                isClosing = false;
                isAnimating = true;
            }
            // 如果卷轴已完全关闭，点击左侧轴也可以展开
            else if (leftIntersects.length > 0 && animationProgress <= 0 && !isAnimating) {
                isClosing = false;
                isAnimating = true;
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
        
        /*
         * 参数说明：
         * 
         * 1. 动画速度调节
         *    - ANIMATION_DURATION: 控制卷轴完全展开的总时长（毫秒）
         *    - 当前值：9000（9秒）
         *    - 调节方法：增大数值减慢速度，减小数值加快速度
         *    - 推荐范围：6000-12000（6-12秒）
         * 
         * 2. 卷轴尺寸调节
         *    - SCROLL_WIDTH: 卷轴总宽度（Three.js单位）
         *    - SCROLL_HEIGHT: 卷轴高度（Three.js单位）
         *    - AXIS_RADIUS: 卷轴轴的半径（Three.js单位）
         * 
         * 3. 视觉效果调节
         *    - 文字大小：在updateTextDisplay函数中修改ctx.font属性
         *    - 文字颜色：在updateTextDisplay函数中修改ctx.fillStyle属性
         *    - 光照强度：在addLighting函数中修改各光源的intensity属性
         * 
         * 4. 性能优化
         *    - 已使用几何体缩放代替频繁重建
         *    - 已启用阴影优化
         *    - 响应式设计确保在不同设备上的良好显示
         */
    </script>
</body>
</html>